/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Virtual Key
 #	author : miyako
 #	2015/06/09
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Virtual Key

		case 1 :
			POST_VIRTUAL_KEY(pResult, pParams);
			break;

		case 2 :
			Test_virtual_key(pResult, pParams);
			break;

	}
}

// ---------------------------------- Virtual Key ---------------------------------

#define Function_key_bit (0) 
#define Command_key_bit (8)

#define Control_key_bit (12)
#define Right_control_key_bit (15)

#define Option_key_bit (11)
#define Right_option_key_bit (14)

#define Shift_key_bit (9)
#define Right_shift_key_bit (13)

void POST_VIRTUAL_KEY(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT Param2;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	unsigned int modifiers = Param2.getIntValue();

    BOOL functionDown = (modifiers >> Function_key_bit) & 1;
    BOOL commandDown = (modifiers >> Command_key_bit) & 1;
    
    BOOL leftControlDown = (modifiers >> Control_key_bit) & 1;
    BOOL rightControlDown = (modifiers >> Right_control_key_bit) & 1;

    BOOL leftOptionDown = (modifiers >> Option_key_bit) & 1;
    BOOL rightOptionDown = (modifiers >> Right_option_key_bit) & 1;
    
    BOOL leftShiftDown = (modifiers >> Shift_key_bit) & 1;
    BOOL rightShiftDown = (modifiers >> Right_shift_key_bit) & 1;

#if VERSIONMAC
        
    CGKeyCode keycode = (CGKeyCode)Param1.getIntValue();
    
    if(keycode == kVK_CapsLock){
    
    //is there a way to simulate caps lock on mac?
    
/*
    about caps lock on mac
    http://stackoverflow.com/questions/7265907/how-to-simulate-caps-lock-keystroke-with-cgeventcreatekeyboardevent-in-os-x
    http://hints.macworld.com/article.php?story=20080202094656148
    http://stackoverflow.com/questions/2935931/cant-block-capslock-with-cgeventtap
    http://forums.macrumors.com/threads/simulate-key-to-activate-caps-lock.1120917/
    http://osxbook.com/book/bonus/chapter10/kbdleds/download/keyboard_leds.c

 */

 /*    
        NSEvent *e = [NSEvent 
        keyEventWithType:NSFlagsChanged
        location:NSZeroPoint
        modifierFlags:NSAlphaShiftKeyMask | NSDeviceIndependentModifierFlagsMask
        timestamp:[NSDate timeIntervalSinceReferenceDate]//CFAbsoluteTimeGetCurrent()
        windowNumber:0//[[[NSApplication sharedApplication]mainWindow]windowNumber]
        context:nil//[NSGraphicsContext currentContext]
        characters:@""
        charactersIgnoringModifiers:@""
        isARepeat:NO
        keyCode:keycode];
        
        [[NSApplication sharedApplication]sendEvent:e];
    */
    
    }else{
    
        CGEventRef e;
            
        CGEventSourceRef eventSource = CGEventSourceCreate(kCGEventSourceStateHIDSystemState);    
        CGEventFlags eventFlags = 0;
     
        if(leftControlDown || rightControlDown){
            eventFlags += NX_CONTROLMASK;
        }
        
        if(leftOptionDown || rightOptionDown){
            eventFlags += NX_ALTERNATEMASK;
        }
        
        if(leftShiftDown || rightShiftDown){
            eventFlags += NX_SHIFTMASK;
        }
        
        if(commandDown){
            eventFlags += NX_COMMANDMASK;
        }

        if(functionDown){
            e = CGEventCreateKeyboardEvent (eventSource, (CGKeyCode)kVK_Function, true);
            CGEventPost(kCGHIDEventTap, e);
            CFRelease(e);
        }

        /* the actual key up-down event  */
                        
            e = CGEventCreateKeyboardEvent (eventSource, keycode, true);
            CGEventSetFlags(e, eventFlags );
            CGEventPost(kCGHIDEventTap, e);
            CFRelease(e);   
               
            e = CGEventCreateKeyboardEvent (eventSource, keycode, false);
            CGEventSetFlags(e, eventFlags );
            CGEventPost(kCGHIDEventTap, e);
            CFRelease(e);    

        if(functionDown){
            e = CGEventCreateKeyboardEvent (eventSource, (CGKeyCode)kVK_Function, false);
            CGEventPost(kCGHIDEventTap, e);
            CFRelease(e);
        }  
        
        CFRelease(eventSource);
    }
#endif

#if VERSIONWIN

    INPUT m[1];
    INPUT e[2];
    
    if(leftControlDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LCONTROL;
        SendInput(1, m, sizeof(INPUT));
    }
    
    if(rightControlDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RCONTROL;
        SendInput(1, m, sizeof(INPUT));
    }
   
    if(leftOptionDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LMENU;
        SendInput(1, m, sizeof(INPUT));
    }

    if(rightOptionDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RMENU;
        SendInput(1, m, sizeof(INPUT));
    }

    if(leftShiftDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LSHIFT;
        SendInput(1, m, sizeof(INPUT));
    }

    if(rightShiftDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RSHIFT;
        SendInput(1, m, sizeof(INPUT));
    }
                     
        ZeroMemory(e, sizeof(e)); 
        e[0].type = e[1].type = INPUT_KEYBOARD;
        e[0].ki.wVk = e[1].ki.wVk = Param1.getIntValue();
        e[1].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(2, e, sizeof(INPUT));

    if(rightShiftDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RSHIFT;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }  
    
    if(leftShiftDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LSHIFT;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }  
    
    if(rightOptionDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RMENU;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }  
    
    if(leftOptionDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LMENU;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }  
    
    if(rightControlDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_RCONTROL;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }    
        
    if(leftControlDown){
        ZeroMemory(m, sizeof(m)); 
        m[0].type = INPUT_KEYBOARD;
        m[0].ki.wVk = VK_LCONTROL;
        m[0].ki.dwFlags =KEYEVENTF_KEYUP;
        SendInput(1, m, sizeof(INPUT));
    }    
    
#endif
}

void Test_virtual_key(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);

#if VERSIONWIN
	returnValue.setIntValue(GetKeyState(Param1.getIntValue()) & 1);
#else
    returnValue.setIntValue(CGEventSourceKeyState(kCGEventSourceStateHIDSystemState, Param1.getIntValue()) & 1);    
#endif

	returnValue.setReturn(pResult);
}
